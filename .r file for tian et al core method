install.packages("dplyr")
install.packages("Matrix")
install.packages("igraph")

library(dplyr)
library(Matrix)
library(igraph)

FILE_PATH <- "/Users/salmamoustafa/replication_edges_clean.csv"
ALPHA_M <- 0.01
ALPHA_L <- 0.20

# STEP 1: DATA PREPARATION CREATING BIPARTITE AND BIADJACENCY MATRIX 
df <- read.csv(FILE_PATH, na.strings = c("", "NA")) %>%
  filter(!is.na(order_id), !is.na(product_name), !is.na(product_name)) %>%
  mutate(
    order_cat   = as.integer(factor(order_id)),
    product_cat = as.integer(factor(product_name))
  )

n_transactions <- n_distinct(df$order_id)
n_products     <- n_distinct(df$product_name)

A_b <- sparseMatrix(
  i = df$order_cat,
  j = df$product_cat,
  x = 1,
  dims = c(n_transactions, n_products)
)

products <- sort(unique(df$product_name))
colnames(A_b) <- products

# STEP 2: NULL MODEL - ERDOS REYNI BIPARTITITE VARIANT
cn_matrix <- crossprod(A_b)   # t(A_b) %*% A_b
diag(cn_matrix) <- 0

d_p <- colSums(A_b)
p_i <- d_p / n_transactions
p_outer <- outer(p_i, p_i)

expected_cn <- n_transactions * p_outer
sigma_er <- sqrt(expected_cn * (1 - p_outer))
sigma_er[sigma_er == 0] <- 1

# Complements: significantly more co-purchases
A_m <- (cn_matrix > expected_cn + qnorm(1 - ALPHA_M) * sigma_er)
# Substitutes: significantly fewer co-purchases AND share complements
A_l <- (cn_matrix < expected_cn + qnorm(ALPHA_L) * sigma_er)
has_common_complement <- (A_m %*% t(A_m)) > 0

A_c <- A_m * 1
A_s <- (A_l & has_common_complement) * 1
diag(A_s) <- 0


# STEP 3: ORIGINAL MEASURES FOR WEIGHTED NETWORKS 

#EQUATION 1 - ORIGINAL COMPLEMENTARITY MEASURE 
d_t <- rowSums(A_b)
d_t_inv <- ifelse(d_t > 0, 1/d_t, 0)
N <- t(A_b) %*% Diagonal(x = d_t_inv) %*% A_b

denom_vec <- t(A_b) %*% d_t_inv
norm_matrix_denom <- sqrt(outer(denom_vec, denom_vec, "*"))
norm_matrix_denom[norm_matrix_denom == 0] <- 1 

sim_o_matrix <- N / norm_matrix_denom

#Weighted adjacency matrix of complement unipartite network a_c *sim
W_c <- A_c * sim_o_matrix 


# EQUATION 2 - SUBSTITUABILITY WEIGHTED MEASURES 

# Compute row norms of W_c
row_norms <- sqrt(rowSums(W_c^2))
# Normalise each row of W_c
Wc_norm <- W_c / row_norms
# Row-wise cosine similarities = dot product of normalised rows
sim_s_matrix <- Wc_norm %*% t(Wc_norm)
# Weighted adjacency matrix of substitute unipartite network  a_s * sim 
W_s <- sim_s_matrix * A_s

# Apply complementarity score threshold
non_zero_W_c <- W_c[W_c > 0]
threshold_c <- quantile(non_zero_W_c, probs = 0.35)
W_c[W_c < threshold_c] <- 0

# Apply substitutability score threshold
threshold_s <- 0
W_s[W_s < threshold_s] <- 0

print(W_c)
print(W_s)

# STEP 4: ROLE EXTRACTION USING INFOMAP

# Infomap requires edge list format
g_comp <- graph_from_adjacency_matrix(W_c, mode = "undirected", weighted = TRUE, diag = FALSE)
g_subs <- graph_from_adjacency_matrix(W_s, mode = "undirected", weighted = TRUE, diag = FALSE)

# Get the community assignments
comp_roles <- cluster_infomap(g_comp, e.weights = E(g_comp)$weight)
subs_roles <- cluster_infomap(g_subs, e.weights = E(g_subs)$weight)

print(comp_roles)
print(subs_roles)

# for comp_roles infomap groups 19, mod 0.72
# for sub roles infomap groups 7, mod 0.6

# STEP 5: COMPUTE ROLE ADJACENCY MATRIX B

# Optimized function to compute the B matrix
# W: the weighted adjacency matrix (W_c or W_s)
# roles: the community assignments from Infomap
compute_role_adjacency_optimized <- function(W, roles) {
  num_roles <- max(roles$membership)
  role_memberships <- roles$membership
  
  # Create a sparse indicator matrix for the roles
  # This matrix maps each product to its community
  role_matrix <- sparseMatrix(
    i = 1:length(role_memberships),
    j = role_memberships,
    x = 1,
    dims = c(length(role_memberships), num_roles)
  )
  
  # Calculate the sum of weights between roles using matrix multiplication
  sum_of_weights <- t(role_matrix) %*% W %*% role_matrix
  
  # Calculate the number of possible connections
  role_sizes <- colSums(role_matrix)
  connections_matrix <- outer(role_sizes, role_sizes, `*`)
  
  # Handle the diagonal (intra-community connections)
  diag(connections_matrix) <- role_sizes * (role_sizes - 1)
  
  # Calculate the average weight
  B_matrix <- sum_of_weights / connections_matrix
  
  return(B_matrix)
}

# Now, you would call this function for your different networks and roles
B_comp_on_comp <- compute_role_adjacency_optimized(W_c, comp_roles)
B_subs_on_subs <- compute_role_adjacency_optimized(W_s, subs_roles)
B_subs_on_comp <- compute_role_adjacency_optimized(W_c, subs_roles)

print("B matrix for complement roles on complement network:")
print(B_comp_on_comp)

print("B matrix for substitute roles on substitute network:")
print(B_subs_on_subs)

print("B matrix for substitute roles on complement network:")
print(B_subs_on_comp)


