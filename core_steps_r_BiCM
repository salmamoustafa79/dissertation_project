install.packages("dplyr")
install.packages("Matrix")
install.packages("igraph")

library(dplyr)
library(Matrix)
library(igraph)

FILE_PATH <- "/Users/salmamoustafa/replication_edges_clean.csv"
ALPHA_M <- 0.01
ALPHA_L <- 0.20

# STEP 1: DATA PREPERATION CREATING BIPARTITE AND BIADJACNEY MATRIX 

df <- read.csv(FILE_PATH, na.strings = c("", "NA")) %>%
  filter(!is.na(order_id), !is.na(product_name), !is.na(product_name)) %>%
  mutate(
    order_cat   = as.integer(factor(order_id)),
    product_cat = as.integer(factor(product_name))
  )

n_transactions <- n_distinct(df$order_id)
n_products     <- n_distinct(df$product_name)

A_b <- sparseMatrix(
  i = df$order_cat,
  j = df$product_cat,
  x = 1,
  dims = c(n_transactions, n_products)
)

products <- sort(unique(df$product_name))
colnames(A_b) <- products



# STEP 2: NULL MODEL â€” BiCM 
cn_matrix <- crossprod(A_b)   # observed co-purchases: t(A_b) %*% A_b
diag(cn_matrix) <- 0

d_p <- colSums(A_b)           # product degrees
d_t <- rowSums(A_b)           # basket sizes
m   <- sum(d_p)               # total edges

mean_dt  <- mean(d_t)
mean_dt2 <- mean(d_t^2)

expected_cn_bicm <- outer(d_p, d_p, function(dp_i, dp_j) {
  (dp_i * dp_j / m) * ((mean_dt2 - mean_dt) / mean_dt)
})

sigma_bicm <- sqrt(expected_cn_bicm)
sigma_bicm[sigma_bicm == 0] <- 1

A_m <- (cn_matrix > expected_cn_bicm + qnorm(1 - ALPHA_M) * sigma_bicm)                     # "more"
A_l <- (cn_matrix < expected_cn_bicm - qnorm(1 - ALPHA_L) * sigma_bicm)                     # "less" (note the minus)

has_common_complement <- (A_m %*% t(A_m)) > 0

A_c <- A_m * 1
A_s <- (A_l & has_common_complement) * 1
diag(A_s) <- 0



# STEP 3: ORIGINAL MEASURES FOR WEIGHTED NETWORKS 

#EQUATION 1 - ORIGINAL COMPLEMENTARITY MEASURE 
d_t <- rowSums(A_b)
d_t_inv <- ifelse(d_t > 0, 1/d_t, 0)
N <- t(A_b) %*% Diagonal(x = d_t_inv) %*% A_b

denom_vec <- t(A_b) %*% d_t_inv
norm_matrix_denom <- sqrt(outer(denom_vec, denom_vec, "*"))
norm_matrix_denom[norm_matrix_denom == 0] <- 1 

sim_o_matrix <- N / norm_matrix_denom

#Weighted adjancency matrix of complement unipartite network a_c *sim
W_c <- A_c * sim_o_matrix 


# EQUATION 2 - SUBSTITUABILITY WEIGHTED MEASURES 

# Compute row norms of W_c
row_norms <- sqrt(rowSums(W_c^2))
# Normalise each row of W_c
Wc_norm <- W_c / row_norms
# Row-wise cosine similarities = dot product of normalised rows
sim_s_matrix <- Wc_norm %*% t(Wc_norm)
# Weighted adjancency matrix of substitiute unipartite network  a_s * sim 
W_s <- sim_s_matrix * A_s

# Apply complementarity score threshold
non_zero_W_c <- W_c[W_c > 0]
threshold_c <- quantile(non_zero_W_c, probs = 0.35)
W_c[W_c < threshold_c] <- 0

# Apply substitutability score threshold
threshold_s <- 0
W_s[W_s < threshold_s] <- 0

print(W_c)
print(W_s)

# STEP 4: ROLE EXTRACTION USING INFOMAP

g_comp <- graph_from_adjacency_matrix(W_c, mode = "undirected", weighted = TRUE, diag = FALSE)
g_subs <- graph_from_adjacency_matrix(W_s, mode = "undirected", weighted = TRUE, diag = FALSE)

comp_roles <- cluster_infomap(g_comp, e.weights = E(g_comp)$weight)
subs_roles <- cluster_infomap(g_subs, e.weights = E(g_subs)$weight)

print(comp_roles)
print(subs_roles)

# for comp_roles infomap groups 19, mod 0.72
# for sub roles infomap groups 7, mod 0.6

# STEP 5: COMPUTE ROLE ADJACENCY MATRIX B

# Optimized function to compute the B matrix

compute_role_adjacency_optimized <- function(W, roles) {
  num_roles <- max(roles$membership)
  role_memberships <- roles$membership
  
 
  role_matrix <- sparseMatrix(
    i = 1:length(role_memberships),
    j = role_memberships,
    x = 1,
    dims = c(length(role_memberships), num_roles)
  )
  
  sum_of_weights <- t(role_matrix) %*% W %*% role_matrix
  
  role_sizes <- colSums(role_matrix)
  connections_matrix <- outer(role_sizes, role_sizes, `*`)
  
  diag(connections_matrix) <- role_sizes * (role_sizes - 1)
  
  B_matrix <- sum_of_weights / connections_matrix
  
  return(B_matrix)
}

B_comp_on_comp <- compute_role_adjacency_optimized(W_c, comp_roles)
B_subs_on_subs <- compute_role_adjacency_optimized(W_s, subs_roles)
B_subs_on_comp <- compute_role_adjacency_optimized(W_c, subs_roles)

print("B matrix for complement roles on complement network:")
print(B_comp_on_comp)

print("B matrix for substitute roles on substitute network:")
print(B_subs_on_subs)

print("B matrix for substitute roles on complement network:")
print(B_subs_on_comp)
